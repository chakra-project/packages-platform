#!/bin/bash

#
# fbsplash-initscripts-simulate
#
error() {
	echo "$@" >&2
	exit 1
}

usage() {
	error "Usage: ${0##*/} <theme> <runlevel> [<prevlevel>] [fail] [fade] [[<sleep-seconds>].[fraction]]" >&2
}

[ $# -ge 2 ] || usage

if [[ $EUID != 0 ]]; then
	echo "${0##*/} has to be called as root !" >&2
	exit 1
fi

# The minimal kernel line parameter
export splash="silent,theme:${1}"
shift

export RUNLEVEL="${1}"
shift

case ${RUNLEVEL}
in [2-5]   ) PREVLEVEL=N
;; [06sS1] ) PREVLEVEL=5; RUNLEVEL=${RUNLEVEL^*}
;; *       ) error Not supported: "${PREVLEVEL}->${RUNLEVEL}"
esac

sleep_time=0
while [ $# -gt 0 ]; do
	case ${1}
	in fail     ) fail=1          ; shift
	;; [NsS1-5] ) PREVLEVEL=${1^*}; shift
	;; *.*      ) sleep_time=${1} ; shift
	;; fade     ) splash+=,fadein,fadeout; shift
	;; *        ) usage
	esac
done

case ${PREVLEVEL}
in [^NS1-5] | $RUNLEVEL ) error Not supported: "${PREVLEVEL}->${RUNLEVEL}"
esac

splash_var_run_daemons=/var/run/daemons
case ${PREVLEVEL}_${RUNLEVEL} in ( [S1]_[06] ) 
	splash_var_run_daemons=$( mktemp -d ${0##*/}.XXXXXX )
esac

export PREVLEVEL

sleep $sleep_time || usage

SPLASH_SINGLE=0

case ${PREVLEVEL}_${RUNLEVEL}
in *_[06] | [^N]_[S1] )

	echo "  Preparing '${PREVLEVEL}->${RUNLEVEL}' simulation"

;; *_[S1-5] )

	if [[ ${PREVLEVEL} = "N" && ${RUNLEVEL} != [S1] ]]; then
		echo "  Preparing full bootup ->'${RUNLEVEL}' simulation"
	else
		echo "  Preparing '${PREVLEVEL}->${RUNLEVEL}' simulation"
		SPLASH_SINGLE=1
	fi

;; * ) usage
esac

simulation_override() {

## code derived from fbsplash.inithooks (proposed for initscripts functions) ####

start_daemon() {
	local daemon=$1
	run_hook pre_daemon_start
	simulate_script /etc/rc.d/$1 start
	local daemonret=$?
	run_hook post_daemon_start
	return $daemonret
}

start_daemon_bkgd() {
	stat_bkgd "Starting $1"
	local daemon=$1
	run_hook fork_daemon_bkgd
	(
		run_hook pre_daemon_bkgd
		simulate_script /etc/rc.d/$1 start
		local daemonret=$?
		run_hook post_daemon_bkgd
	) &>/dev/null &
}

stop_daemon() {
	local daemon=$1
	run_hook pre_daemon_stop
	simulate_script /etc/rc.d/$1 stop
	local daemonret=$?
	run_hook post_daemon_stop
	return $daemonret
}

#########################################################################

}

# args: daemon start|stop
#

simulate_script() {
	(
		splash_script_path=$1
		splash_script=${splash_script_path#/etc/rc.}
		
		stat_busy "Fake $1 $2"
		sleep $sleep_time
		if [[ $fail ]]; then
			stat_fail
		else
			stat_done
		fi
	)
}

simulate() {
	sleep $sleep_time
}

simulate_fail() {
	sleep $sleep_time
	[[ -z $fail ]]
}

(
	case ${PREVLEVEL}_${RUNLEVEL}
	
	in ( N_[S1-5] ) ######################################################

		echo "  Simulating rc.sysinit"

		RUNLEVEL="S"

		splash_script_path=/etc/rc.sysinit

		. /etc/rc.conf
		if [[ $fail ]]; then
			DAEMONS=( not-there "${DAEMONS[@]}" )
		fi
		. ${0}-functions
		simulation_override
		echo "  using DAEMONS=( ${DAEMONS[@]} )"

## code derived from initscripts 2010.01-1 rc.sysinit ###################

run_hook sysinit_start

stat_busy "Starting UDev Daemon"
	simulate
stat_done

run_hook sysinit_udevlaunched

if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
  stat_busy "Triggering UDev uevents"
  simulate
  stat_done
fi

if ! [ "$load_modules" = "off" ]; then
	if [ -f /proc/modules ]; then
		stat_busy "Loading Modules"
		simulate
		stat_done
	fi
fi

# Wait for udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
	stat_busy "Waiting for UDev uevents to be processed"
	simulate
	stat_done
fi

run_hook sysinit_udevsettled

# bring up the loopback interface
if [ -d /sys/class/net/lo ]; then
	stat_busy "Bringing up loopback interface"
	simulate
	if [ $? -ne 0 ]; then
		stat_fail
	else
		stat_done
	fi
fi

if [ -f /etc/mdadm.conf -a "$(/bin/grep ^ARRAY /etc/mdadm.conf 2>/dev/null)" ]; then
	status "Activating RAID arrays" simulate
fi

if [ "$USELVM" = "yes" -o "$USELVM" = "YES" ]; then
	if [ -x /sbin/lvm -a -d /sys/block ]; then
		stat_busy "Activating LVM2 groups"
		simulate
		if [ $? -ne 0 ]; then
			stat_fail
		else
			stat_done
		fi
	fi
fi

if [ -f /etc/crypttab -a -n "$(/bin/grep -v ^# /etc/crypttab | /bin/grep -v ^$)" ]; then
	stat_busy "Unlocking encrypted volumes:"
	csfailed=0
	do_crypt() {
		if [ $# -ge 3 ]; then
			cname="$1"
			stat_append "${cname}.."
			simulate
			if [ $? -ne 0 ]; then
				csfailed=1
				stat_append "failed "
			else
				stat_append "ok "
			fi
		fi
	}
	while read line; do
		eval do_crypt "$line"
	done </etc/crypttab
	if [ $csfailed -eq 0 ]; then
		stat_done
	else
		stat_fail
	fi
fi

status "Mounting Root Read-only" simulate

if [ -x /sbin/fsck ]; then
	stat_busy "Checking Filesystems"
	simulate
	stat_done
fi

stat_busy "Mounting Local Filesystems"
run_hook sysinit_premount
simulate
stat_done

status "Activating Swap" simulate_fail

stat_busy "Configuring System Clock"
simulate
stat_done

RANDOM_SEED=/var/lib/misc/random-seed
if [ -f $RANDOM_SEED ]; then
	stat_busy "Initializing Random Seed"
	simulate
	stat_done
fi

stat_busy "Removing Leftover Files"
simulate
stat_done

#status "Updating Shared Library Links" simulate

if [ "$HOSTNAME" != "" ]; then
	status "Setting Hostname: $HOSTNAME" simulate
fi

# Set the NIS domain name, if necessary
[ -f /etc/conf.d/nisdomainname ] && . /etc/conf.d/nisdomainname
if [ "$NISDOMAINNAME" != "" ]; then
	status "Setting NIS Domain Name: $NISDOMAINNAME" simulate
fi

status "Updating Module Dependencies" simulate

stat_busy "Setting Locale: $LOCALE"
simulate
stat_done

if echo "$LOCALE" | /bin/grep -qi utf ; then
	stat_busy "Setting Consoles to UTF-8 mode"
	simulate
	stat_done
	[ -n "$KEYMAP" ] && status "Loading Keyboard Map: $KEYMAP" simulate
else
	stat_busy "Setting Consoles to legacy mode"
	simulate
	stat_done
	[ -n "$KEYMAP" ] && status "Loading Keyboard Map: $KEYMAP" simulate
fi

if [ -n "$CONSOLEFONT" ]; then
	stat_busy "Loading Console Font: $CONSOLEFONT"
	#CONSOLEMAP in UTF-8 shouldn't be used
	if [ -n "$CONSOLEMAP" ] && echo "$LOCALE" | /bin/grep -qi utf ; then
		CONSOLEMAP=""
	fi
	simulate
	if [ $? -ne 0 ]; then
		stat_fail
	else
		stat_done
	fi
fi

# Adding persistent network/cdrom generated rules
if [ -f "/dev/.udev/tmp-rules--70-persistent-cd.rules" ]; then
	stat_busy "Adding persistent cdrom udev rules"
	simulate
	stat_done
fi
if [ -f "/dev/.udev/tmp-rules--70-persistent-net.rules" ]; then
	stat_busy "Adding persistent network udev rules"
	simulate
	stat_done
fi

run_hook sysinit_end

#########################################################################

	;; ( *_[06] | [^N]_[S1] ) ############################################

		if [[ ${RUNLEVEL} == [06] ]]; then
			splash_test_name=shutdown
		else
			splash_test_name=single
		fi
		
		echo "  Simulating rc."$splash_test_name
		splash_script_path=/etc/rc.$splash_test_name

		. /etc/rc.conf
		if [[ $fail ]]; then
			DAEMONS=( not-there "${DAEMONS[@]}" )
		fi
		. ${0}-functions
		simulation_override
		echo "  using daemons:" $( /bin/ls -t $splash_var_run_daemons )
		echo "  using DAEMONS=( ${DAEMONS[@]} )"

		if [[ ${RUNLEVEL} == [06] ]]; then

## code derived from initscripts 2010.01-1 rc.shutdown ##################

run_hook shutdown_start

if [ -x /etc/rc.local.shutdown ]; then
	simulate_script /etc/rc.local.shutdown
fi

#########################################################################

	else
	
run_hook single_start

	fi

if [ -d $splash_var_run_daemons ]; then
	for daemon in $( /bin/ls -t $splash_var_run_daemons ); do
		if ! in_array $daemon ${DAEMONS[@]}; then
			stop_daemon $daemon
		fi
	done
fi
let i=${#DAEMONS[@]}-1
while [ $i -ge 0 ]; do
	if [ "${DAEMONS[$i]:0:1}" != '!' ]; then
		ck_daemon ${DAEMONS[$i]#@} || stop_daemon ${DAEMONS[$i]#@}
	fi
	let i=i-1
done

stat_busy "Sending SIGTERM To Processes"
run_hook shutdown_prekillall
/usr/bin/killall -s 15 fbsplashd.static
/bin/sleep 5
stat_done

stat_busy "Sending SIGKILL To Processes"
/usr/bin/killall -s 9 fbsplashd.static
/bin/sleep 1
stat_done

		if [[ ${RUNLEVEL} == [06] ]]; then

run_hook shutdown_postkillall

stat_busy "Saving Random Seed"
simulate
stat_done

stat_busy "Saving System Clock"
simulate
stat_done

stat_busy "Deactivating Swap"
simulate
stat_done

stat_busy "Unmounting Filesystems"
simulate
stat_done

if [ -f /etc/crypttab -a -n "$(/bin/grep -v ^# /etc/crypttab | /bin/grep -v ^$)" ]; then
	stat_busy "Deactivating encrypted volumes:"
	do_uncrypt() {
		if [ $# -ge 3 ]; then
			if [ -b /dev/mapper/$1 ] ;then
				stat_append "${1}.."
				simulate
				if [ $? -ne 0 ]; then
					stat_append "failed "
				else
					stat_append "ok "
				fi
			fi
		fi
	}
	while read line; do
		eval do_uncrypt "$line"
	done </etc/crypttab
	stat_done
fi

if [ "$USELVM" = "yes" -o "$USELVM" = "YES" ]; then
	if [ -x /sbin/lvm -a -d /sys/block ]; then
		stat_busy "Deactivating LVM2 groups"
		simulate
		stat_done
	fi
fi

stat_busy "Remounting Root Filesystem Read-only"
simulate
stat_done

run_hook shutdown_poweroff

#########################################################################

		else

## code derived from initscripts 2010.01-1 rc.single ####################

	run_hook single_postkillall

	stat_busy "Starting UDev Daemon"
	simulate
	stat_done

	run_hook single_udevlaunched

	if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
	  stat_busy "Triggering UDev uevents"
	  simulate
	  stat_done
	fi

	if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
		stat_busy "Waiting for UDev uevents to be processed"
		simulate
		stat_done
	fi

	run_hook single_udevsettled

	if [ -x /etc/rc.d/syslog-ng ]; then
		simulate_script /etc/rc.d/syslog-ng start
	elif [ -x /etc/rc.d/syslogd ]; then
		simulate_script /etc/rc.d/syslogd start
		[ -x /etc/rc.d/klogd ] && simulate_script /etc/rc.d/klogd start
	fi
fi

run_hook single_end

#########################################################################


	esac
)

(
	case ${PREVLEVEL}_${RUNLEVEL}
	
	in ( [NS1]_[2-5] ) ##################################################

		echo "  Simulating rc.multi"

		splash_script_path=/etc/rc.multi

		. /etc/rc.conf
		if [[ $fail ]]; then
			DAEMONS=( not-there "${DAEMONS[@]}" )
		fi
		. ${0}-functions
		simulation_override

## code derived from initscripts 2010.01-1 rc.multi #####################

run_hook multi_start

# Start daemons
for daemon in "${DAEMONS[@]}"; do
	if [ "$daemon" = "${daemon#!}" ]; then
		if [ "$daemon" = "${daemon#@}" ]; then
			start_daemon $daemon
		else
			start_daemon_bkgd ${daemon:1}
		fi
	fi
done

if [ -x /etc/rc.local ]; then
	simulate_script /etc/rc.local
fi

run_hook multi_end

#########################################################################

	esac
)

[[ $splash_var_run_daemons != /var/run/daemons ]] && rmdir $splash_var_run_daemons

echo "  'splash'  mounted:"
cat /proc/mounts | grep splash
echo "  'splashd' running:"
ps -Af | grep splashd | grep -v grep
echo "  Log files found:"
{
	find /lib/splash/cache -type f -name profile -printf '%T+ %p\n'
	find /lib/splash/tmp   -type f -name profile -printf '%T+ %p\n'
} | sort

# EOF #
